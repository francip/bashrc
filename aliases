#!/bin/bash

# This file is not intended for direct execution
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then exit; fi

# Common aliases and functions

__aliases_main() {
    local BASH_SOURCE_FILE BASH_SOURCE_DIR BASH_SOURCE_FILE_ESCAPED

    BASH_SOURCE_FILE=${BASH_SOURCE[0]}
    while [[ -L "$BASH_SOURCE_FILE" ]]; do
        BASH_SOURCE_FILE=$(readlink "$BASH_SOURCE_FILE")
    done

    BASH_SOURCE_DIR=$(dirname "$BASH_SOURCE_FILE")
    BASH_SOURCE_DIR=`cd "$BASH_SOURCE_DIR" >/dev/null; pwd`
    BASH_SOURCE_FILE=$(basename "$BASH_SOURCE_FILE")
    BASH_SOURCE_FILE_ESCAPED=${BASH_SOURCE_FILE// /_}

    # BASH_SOURCE_DIR is a full path to the location of this script

    eval "$(cat <<EOF
        __get_${BASH_SOURCE_FILE_ESCAPED}_dir() {
          echo $BASH_SOURCE_DIR
        }
        __get_${BASH_SOURCE_FILE_ESCAPED}_file() {
          echo $BASH_SOURCE_FILE
        }
EOF
)"

    eval "$(_bash_color_definitions)"
    eval "$(_bash_os_definitions)"

    # Early load before bashrc main started

    alias cls='clear'

    alias grep='grep --color=auto '
    alias fgrep='fgrep --color=auto '
    alias egrep='egrep --color=auto '

    alias dir='ls -al '

    alias ps='ps -ef '
    alias psu='ps -u ${USER} '

    alias avd='android avd & '

    if [[ -n CDPATH ]]; then
        # Replace the cd builtin to turn off the annoying
        # echo-new-folder behavior when CDPATH is set
        cd() {
            local DEST=$*
            if [[ -z $DEST ]]; then
                DEST=~
            fi
            builtin cd "${DEST}" >/dev/null
        }
    fi

    ff() {
        find . -name "*" -type f -exec grep --color=auto -HinF "$@" {} \;
    }

    ff2() {
        # Double-grep to filter out grep warnings
        grep --color=auto -RHinF "$@" * 2>&1 | grep --color=auto -i "$@"
    }

    fff() {
        find . -name "$1" -type f -exec grep --color=auto -HinF "${@:2}" {} \;
    }

    fff2() {
        # Double-grep to filter out grep warnings
        grep --color=auto -RHinF "${@:2}" "$1" 2>&1 | grep --color=auto -i "${@:2}"
    }

    ffs() {
        set | grep --color=auto -i "$@"
    }

    fn() {
        find -L . -iname "$@"
    }

    fp() {
        ps | grep --color=auto -i "$@"
    }

    rmr() {
        eval "$(_bash_color_definitions)"

        if [[ $# -eq 0 ]]; then
            echo -e "Usage: "$COLOR_YELLOW_BOLD"rmr"$COLOR_NONE" "$COLOR_CYAN_BOLD"{pattern}"$COLOR_NONE" "$COLOR_CYAN_BOLD"{rm options}"$COLOR_NONE
            echo
            echo -e $COLOR_YELLOW_BOLD"Rmr"$COLOR_NONE" will execute recursive rm on any files matching the "$COLOR_CYAN_BOLD"pattern"$COLOR_NONE
            echo -e "skipping matching files in hidden subdirectories."
            echo
            echo -e $COLOR_RED_BOLD"Warning:"$COLOR_NONE" rmr is dangerous!"
            echo
        else
            find . -name "$1" ! -path '*/.*' -exec rm "${@:2}" {} \;
        fi
    }

    rmr2() {
        eval "$(_bash_color_definitions)"

        if [[ $# -eq 0 ]]; then
            echo -e "Usage: "$COLOR_YELLOW_BOLD"rmr"$COLOR_NONE" "$COLOR_CYAN_BOLD"{pattern}"$COLOR_NONE" "$COLOR_CYAN_BOLD"{rm options}"$COLOR_NONE
            echo
            echo -e $COLOR_YELLOW_BOLD"Rmr"$COLOR_NONE" will execute recursive rm on any files matching the "$COLOR_CYAN_BOLD"pattern"$COLOR_NONE"."
            echo
            echo -e $COLOR_RED_BOLD"Warning:"$COLOR_NONE" rmr is dangerous!"
            echo
        else
            find . -name "$1" -exec rm "${@:2}" {} \;
        fi
    }

    check-whitespace() {
        # Look for trailing spaces
        grep -r -n '[[:space:]]$' *

        # Look for leading tabs
        grep -r -n '^\t' *
    }

    get_ssh_client_ip() {
        local SSH_ARGS=($SSH_CLIENT)
        echo ${SSH_ARGS[0]}
    }

    groot() {
        local GIT_ROOT=$(git rev-parse --show-toplevel)
        cd $GIT_ROOT/"$@"
    }

    hroot() {
        local HG_ROOT=$(hg root)
        cd $HG_ROOT/"$@"
    }

    ssht() {
        ssh $* -t 'tmux a || tmux || /bin/bash'
    }

    mosht() {
        local HOST
        HOST=$1
        shift
        mosh -6 $HOST -- tmux a "$@"
    }

    # OS-specific aliases and functions

    if [[ $BASH_OS_TYPE == OSX ]]; then
        # OS X aliases
        alias ls='ls -Gp '

        alias www-on='sudo apachectl start'
        alias www-off='sudo apachectl stop'

        alias atompi='ATOM_HOME=$HOME/.atompi atom'
        alias apmpi='ATOM_HOME=$HOME/.atompi apm'

        list() {
            instruments -s devices | grep -i -v "simulator" | tail -n +2
            adb devices | tail -n +2
        }

        ij() {
            open -b com.jetbrains.intellij.ce "$@"
        }

        as() {
            # open -b com.google.android.studio "$@"
            open -a /Applications/Android\ Studio.app "$@"
        }

        g() {
            # Consider hroot if it's a Mercurial repository
            groot
            ./gradlew "$@"
        }

        set-title() {
            eval "$(_bash_color_definitions)"

            local TITLE="$@"
            echo -e "Setting terminal title to "$COLOR_YELLOW_BOLD"$TITLE"$COLOR_NONE
            echo -n -e "\033]0;$TITLE\007"
        }

        ex() {
            if [[ $# -eq 0 ]]; then
                open .
            else
                if [[ -d "$1" ]]; then
                    open "$@"
                else
                    open -R "$@"
                fi
            fi
        }

        rep() {
            eval "$(_bash_color_definitions)"

            if [[ $# -eq 0 ]]; then
                echo -e "Usage: rep {sed command}"
                echo
                echo -e "Rep will execute the sed command on all files in the current directory"
                echo -e "and subdirectories, excluding any hidden files. All commands will be"
                echo -e "executed in place using sed's -i option."
                echo
                echo -e "For example rep s/a/b/ will replace all instances of 'a' in all files with 'b'"
                echo
                echo -e "Read "$COLOR_BOLD"sed"$COLOR_NONE" manual for more details"
                echo
            else
                for x in $(find . -type f -name '*' ! -name '.*' ! -path '*/.*'); do
                    sed -i "" "$@" $x
                done
                # This is a bit dangerous, and assumes that there are no legitimate files
                # that start with .!. Probably should be a bit more careful and match
                # more specifically
                find . -name "\.\!*" -exec rm {} \;
            fi
        }

        latest() {
            if [[ $(which brew 2>/dev/null) ]]; then
                brew analytics off
                brew update
                brew upgrade
                brew cleanup
                brew prune
            fi
            if [[ $(which port 2>/dev/null) ]]; then
                sudo port selfupdate
                sudo port upgrade outdated
                sudo port reclaim
            fi
            if [[ $(which npm 2>/dev/null) ]]; then
                npm install -g npm@latest
                npm update -g
            fi
            if [[ $(which yarn 2>/dev/null) ]]; then
                yarn global upgrade --latest
            fi
            if [[ $(which pip 2>/dev/null) ]]; then
                pip2 install --upgrade pip setuptools
            fi
            if [[ $(which pip3 2>/dev/null) ]]; then
                pip3 install --upgrade pip setuptools
            fi
        }

        mdns_list() {
            dns-sd -B _services._dns-sd._udp .
        }
    fi

    if [[ $BASH_OS_TYPE == Linux ]]; then
        # Linux aliases and functions
        alias ls='ls --color=auto '

        set-title() {
            eval "$(_bash_color_definitions)"

            local TITLE="$@"
            echo -e "Setting terminal title to "$COLOR_YELLOW_BOLD"$TITLE"$COLOR_NONE
            export PROMPT_COMMAND="echo -n -e \"\033]0;$TITLE\007\"";
        }

        rep() {
            eval "$(_bash_color_definitions)"

            if [[ $# -eq 0 ]]; then
                echo -e "Usage: rep {sed command}"
                echo
                echo -e "Rep will execute the sed command on all files in the current directory"
                echo -e "and subdirectories, excluding any hidden files. All commands will be"
                echo -e "executed in place using sed's -i option."
                echo
                echo -e "For example rep s/a/b/ will replace all instances of 'a' in all files with 'b'"
                echo
                sed --help
                echo
            else
                for x in $(find . -type f -name '*' ! -name '.*' ! -path '*/.*'); do
                    sed -i "$@" $x
                done
                # This is a bit dangerous, and assumes that there are no legitimate files
                # that start with .!. Probably should be a bit more careful and match
                # more specifically
                find . -name "\.\!*" -exec rm {} \;
            fi
        }

        if [[ $COLORTERM == gnome-terminal ]] ||
           [[ $SESSIONTYPE == gnome-session ]] ||
           [[ $XDG_CURRENT_DESKTOP == GNOME ]]; then
            ex() {
                if [[ $# -eq 0 ]]; then
                    nautilus . &
                else
                    nautilus "$@" &
                fi
            }

            e() {
                gedit "$@" &
            }

            regedit() {
                gconf-editor "$@" &
            }
        else
            e() {
                vim "$@"
            }
        fi

        if [[ $BASH_OS_DISTRO == CentOS ]]; then
            # CentOS aliases and functions
            alias __dummy='echo dummy'
            # CentOS doesn't have --group-directories-first :-(
            # Hence why dir is specific for Ubuntu and Debian
        fi

        if [[ $BASH_OS_DISTRO == Debian ]] ||
           [[ $BASH_OS_DISTRO == Ubuntu ]] ||
           [[ $BASH_OS_DISTRO == Raspbian ]]; then
            # Debian aliases and functions

            alias dir='ls -al --group-directories-first '

            latest() {
                sudo apt-get update
                sudo apt-get upgrade -y
                if [[ $(which npm 2>/dev/null) ]]; then
                    npm install -g npm@latest
                    npm update -g
                fi
                if [[ $(which yarn 2>/dev/null) ]]; then
                    yarn global upgrade --latest
                fi
                if [[ $(which pip 2>/dev/null) ]]; then
                    sudo pip2 install --upgrade pip setuptools
                fi
                if [[ $(which pip3 2>/dev/null) ]]; then
                    sudo pip3 install --upgrade pip setuptools
                fi
            }
        fi

        if [[ $BASH_OS_DISTRO == Ubuntu ]]; then
            # Ubuntu aliases and functions

            # Ubuntu has a weird bug with graphical sudo and DBUS
            sudo() {
                local _SUDO_SAVE=$DBUS_SESSION_BUS_ADDRESS
                unset DBUS_SESSION_BUS_ADDRESS
                command sudo -E env PATH="$PATH" "$@"
                export DBUS_SESSION_BUS_ADDRESS=$_SUDO_SAVE
            }

            gksudo() {
                local _SUDO_SAVE=$DBUS_SESSION_BUS_ADDRESS
                unset DBUS_SESSION_BUS_ADDRESS
                command gksudo -k "$@" &
                export DBUS_SESSION_BUS_ADDRESS=$_SUDO_SAVE
            }
        fi

        if [[ $BASH_OS_DISTRO == Yocto ]]; then
            # Yocto grep doesn't support --color=auto
            unalias grep

            ff() {
                find . -name "*" -type f -exec grep -HinF "$@" {} \;
            }

            ff2() {
                # Double-grep to filter out grep warnings
                grep -RHinF "$@" * 2>&1 | grep -i "$@"
            }

            fff() {
                find . -name "$1" -type f -exec grep -HinF "${@:2}" {} \;
            }

            fff2() {
                # Double-grep to filter out grep warnings
                grep -RHinF "${@:2}" "$1" 2>&1 | grep -i "${@:2}"
            }

            ffs() {
                set | grep -i "$@"
            }

            fp() {
                ps | grep -i "$@"
            }
        fi
    fi

    if [[ $BASH_OS_TYPE == Windows ]]; then
        # Windows aliases

        alias ls='ls --color=auto'

        e() {
            vim "$@"
        }

        ex() {
            if [[ $# -eq 0 ]]; then
                start .
            else
                if [[ -d "$1" ]]; then
                    start "$@"
                else
                    notepad "$@"
                fi
            fi
        }

        latest() {
            pacman -Syuu
        }
    fi

    # Late load after bashrc main finished

    __aliases_load() {
        local ALIASES_LOAD

        if [[ $BASH_OS_TYPE == OSX ]]; then
            # OS X aliases

            # Check if Visual Code is installed
            # If not, check if Sublime Edit is installed
            # If not, check if TextMate is installed
            # If not, use TextEdit
            e() {
                local CODE_COMMAND SUBL_COMMAND MATE_COMMAND
                CODE_COMMAND=`type -t code`
                SUBL_COMMAND=`type -P subl`
                MATE_COMMAND=`type -P mate`
                if [[ -n $CODE_COMMAND ]]; then
                    # Eval because code command can be alias
                    `code "$@"`
                else
                    if [[ -n $SUBL_COMMAND ]]; then
                        subl "$@"
                    else
                        if [[ -n $MATE_COMMAND ]]; then
                            mate -a -d "$@"
                        else
                            open -e "$@"
                        fi
                    fi
                fi
            }
        fi
    }
}

__aliases_main "$@"
unset __aliases_main
